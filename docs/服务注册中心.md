> 要实现一体机日志信息向多个管理节点推送, 我们需要一个服务注册中心, 我们并不需要如微服务一样考虑分布式, 一致性 问题, 因此本项目手动实现一个单机版的轻量服务注册中心

## 需求分析

- 数据转发: 需要将来自于promtail的数据按照一定策略推送给需要他的loki
- 服务注册: 接收来自管理节点的请求, 将管理节点的Loki对象注册并保存起来
- 服务下线: 接收来自管理节点的主动下线请求, 将自己从注册表移除
- 服务获取: 可以查询注册中心的可用服务(或者查询所有服务的状态)
- 服务续约: 定时对注册表中的服务进行健康检查或者服务主动上报告知服务可用
- 服务剔除: 从注册表按照一定的策略删除不可用的服务

## 数据转发

- promtail 推送的数据格式
```json
{
  "streams": [
    {
      "stream": {
        "label": "value"
      },
      "values": [
          [ "<unix epoch in nanoseconds>", "<log line>" ],
          [ "<unix epoch in nanoseconds>", "<log line>" ]
      ]
    }
  ]
}
```

- 截取到protobuf的数据

```json
{
"level":"info",
"ts":"2021-08-03T11:34:48+08:00",
"caller":"prom/conf.go:72",
"msg":"&PushRequest{Streams:[{{filename=\"/tmp/test.log\", name=\"test\", product=\"qdm\"} [{2021-08-03 03:34:46.978227896 +0000 UTC hello}]}],}"}
```

- 由注册表负责将日志流分发给各个Loki服务

> 每个 `Loki` 对象维护了一个需要监听的日志文件列表, 当 `tailor` 接收到来自于 `promtail` 的数据后, 取出日志流对应的 `filename` 标签值,
> 如果该值存在于 `Loki` 的日志列表, 则将日志推送给 `Loki`

## 服务注册

- `tailor` 不进行持久化存储
- `phoenix` 需要同步日志目标的变化

> 基于以上原因, 业务端需要将loki定时进行注册

## 服务下线

> 该项目中业务端可以主动发起下线请求, 例如告警配置被清空的情况

## 服务获取

```json
{
  "checkUrl": "http://10.10.168.77:20015/ready",
  "paths": [
    "/tmp/*.log",
    "/var/log/message"
  ],
  "url": "http://10.10.168.77:20015/loki/api/v1/push"
}
```

- 通过应用名称(即loki的推送api)来获取单个注册对象
- 通过通配符 `*` 来获取注册表中所有服务

## 服务续约

> 考虑到本项目的特点: `Loki` 本身需要按照一定周期定时前来注册, 同步监听信息. 
> 因此使用注册代替续约

## 服务剔除

- `Loki` 注册时自身携带一个 `TTL` (单次续约有效时常)和一个 `探活api`
- `tailor` 定期检查应用的最后注册时间, 如果超过 `TTL` 则尝试使用 `探活api` 主动检查 `Loki` 状态
- 如果最终探测连接失败, 则将应用从注册表移除

## 异常情况覆盖

- 管理节点挂掉

> `tailor` 可以进行主动确认, 避免重复向挂掉的loki推送,影响整体效率
> 当管理节点恢复后再次注册, 开始正常推送

- 一体机上的 `tailor` 挂掉

  - 当恢复后可以继续接收业务的注册请求, 正常推送日志

> 此时数据无法正常推送给 loki, 此段时间的日志将会丢失
> 此段时间 tailor 本身也可能因为大量重试导致协程数量激增

